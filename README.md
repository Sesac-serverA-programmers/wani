# 러닝메이트 알고리즘 문제풀이

---

### [1. 같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

- **문제 유형 : Stack/Queue**

- 시간복잡도 : `O(1)`

  - 1,000,000 이하의 자연수이므로 시간복잡도는 크지 않다.

- 풀이법 :

  - 선입후출 형식의 **Stack**으로 풀이한다.

  - pop(n)은 리스트 자체를 통째로 복사하기 때문에 O(n)의 시간 복잡도를 가진다.

  - pop()이 아닌 append()함수를 사용해서 새 배열에 옮기면 연산 속도를 단축시킬 수 있다.

---

### [2. 올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)

- **문제 유형 : Stack**

- 시간복잡도 : `O(n)`

  - Stack에 문자열을 넣기 때문에 상수가 아닌 문자가 들어간다.

- 풀이법 :

  - stack 자료형에 들어가는 원소가 `(` 일 경우 :

    - append()를 해서 스택에 집어넣는다.

  - 반대로 들어가는 원소가 `)` 일 경우 :

    - stack에 `(`가 남아 있을 때 :

      - pop()을 이용해서 괄호쌍을 날려준다.

    - stack이 빈 배열일 경우 :

      - `False` 반환

  - 마지막으로 stack에 원소가 남아있으면 `False` 반환

  - pop()으로 모두 날려버리고 stack이 비어있다면 `True` 반환

---

### [3. 더 맵게](https://school.programmers.co.kr/learn/courses/30/lessons/42626)

- **문제 유형 : Heap**

- 시간복잡도 : `O(n)`

  - 리스트에 최솟값을 일반 정렬하면 시간복잡도에서 통과되지 못하므로 힙(heap)을 사용해야 통과할 수 있다!

- 풀이법 :

  - 배열의 최솟값과 두 번째로 작은 값을 더해서 배열의 모든 숫자가 K가 될 때까지 계속 반복한다.

  - `heapq.heappop()`을 이용해서 최솟값과 두 번째 최솟값을 heapq 리스트에서 빼온다.

  - `heapq.heappush()`를 이용해서 스코빌 Heap의 섞은 음식의 스코빌 지수를 넣어준다.

  - 위 과정을 반복할 때 `answer(최소 횟수)` 값을 +1로 계속 올려준다.

  - 모든 음식의 스코빌 지수를 K 이상으로 못 만들 때에는 -1을 반환한다.

---

### [4. 이중우선순위큐](https://school.programmers.co.kr/learn/courses/30/lessons/42628)

- **문제 유형 : Priority Queue**

- 시간복잡도 : `O(nlog(n))`

  - operations 길이 배열이 1,000,000 이하이므로 리스트 정렬로 문제 풀어도 시간복잡도는 초과하지 않을 것 같아서 정렬로 풀이

- 풀이법 :

  - 반복문의 매개변수들을 받고 원소들을 공백으로 split시킨다.

  - append()시에는 음수값들도 들어가기 때문에 정렬을 위해 정수형으로 자료형을 변환시켜서 넣어준다.

  - `a`가 `I`가 아니라 `D`일 경우에는 리스트 내에 원소가 존재하는 지 검사하고

    - b가 `1`일 경우, 배열에서 큐의 최댓값을 `pop()`으로 삭제해준다.

    - 반대로 b가 `-1`일 경우, 배열에서 큐의 최솟값을 `pop(0)`으로 삭제해준다.

  - 리스트가 비어있으면 `[0, 0]`을 반환하고 그렇지 않으면 `[최댓값, 최솟값]`을 반환

- 참고자료 :

  - https://velog.io/@norighthere/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Python-%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90

  - https://codedrive.tistory.com/54

---

### [5. 폰켓몬](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

- **문제 유형 : Hash / Set**

- 시간복잡도 : `O(1)?? 맞나..?`

  - 배열 길이는 10^4 미만이므로 시간복잡도를 상수로 표현 가능할 것 같다.

- 풀이법 :

  - 기본으로 가져가도 되는 폰켓몬의 갯수를 `num`으로 표현

  - 정렬을 이용해서 중복 데이터 제거후 새로 정비된 리스트를 기존 `num`이랑 비교해서 if문 돌려서 최댓값 return
    s

---

### CMC 앱 데모데이 전까지는 알고리즘 문제 풀이가 늦어질 예정..

---
